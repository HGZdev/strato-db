{"version":3,"sources":["../../src/JsonModel/makeMigrations.js"],"names":["cloneModelWithDb","m","db","model","Object","create","_set","_makeSetFn","makeMigrations","name","tableName","idCol","columns","keepRowId","migrations","migrationOptions","tableQuoted","sql","quoteId","allMigrations","quoted","type","autoIncrement","isIntegerId","addRowId","rowIdCol","keySql","exec","col","entries","expr","replace","real","index","unique","ignoreNull","wrappedMigrations","wrapMigration","migration","wrap","fn","writeableDb","store","__madeWriteable","values","forEach","up","keys","k"],"mappings":";;;;;;;AAAA;;;;;;AAEO,MAAMA,gBAAgB,GAAG,CAACC,CAAD,EAAIC,EAAJ,KAAW;AAC1C,QAAMC,KAAK,GAAGC,MAAM,CAACC,MAAP,CAAcJ,CAAd,CAAd;AACAE,EAAAA,KAAK,CAACD,EAAN,GAAWA,EAAX;AACAC,EAAAA,KAAK,CAACG,IAAN,GAAaH,KAAK,CAACI,UAAN,EAAb;AACA,SAAOJ,KAAP;AACA,CALM;;;;AAOA,MAAMK,cAAc,GAAG,CAAC;AAC9BC,EAAAA,IAAI,EAAEC,SADwB;AAE9BC,EAAAA,KAF8B;AAG9BC,EAAAA,OAH8B;AAI9BC,EAAAA,SAJ8B;AAK9BC,EAAAA,UAL8B;AAM9BC,EAAAA;AAN8B,CAAD,KAOxB;AACL,QAAMC,WAAW,GAAGC,QAAIC,OAAJ,CAAYR,SAAZ,CAApB;;AACA,QAAMS,aAAa,qBACfL,UADe;AAElB;AACA,OAAG,OAAO;AAACZ,MAAAA;AAAD,KAAP,KAAgB;AAClB,YAAM;AAACkB,QAAAA,MAAD;AAASC,QAAAA,IAAT;AAAeC,QAAAA;AAAf,UAAgCV,OAAO,CAACD,KAAD,CAA7C;AACA,YAAMY,WAAW,GAAGF,IAAI,KAAK,SAA7B;AACA,YAAMG,QAAQ,GAAG,CAACD,WAAD,IAAgBV,SAAjC,CAHkB,CAIlB;;AACA,YAAMY,QAAQ,GAAGD,QAAQ,GACrB,sDADqB,GAEtB,EAFH;AAGA,YAAME,MAAM,GAAGF,QAAQ,GACnB,GAAEH,IAAK,WADY,GAEnB,GAAEA,IAAK,gBACRE,WAAW,IAAID,aAAf,GAA+B,eAA/B,GAAiD,EAChD,WAJJ;AAMA,YAAMpB,EAAE,CAACyB,IAAH,CACJ,gBAAeX,WAAY,IAAGS,QAAS,GAAEL,MAAO,IAAGM,MAAO,eADtD,CAAN;;AAGA,UAAIF,QAAJ,EAAc;AACb;AACA,cAAMtB,EAAE,CAACyB,IAAH,CACJ,uBAAsBV,QAAIC,OAAJ,CACrB,GAAER,SAAU,IAAGC,KAAM,EADA,CAErB,OAAMK,WAAY,IAAGC,QAAIC,OAAJ,CAAYP,KAAZ,CAAmB,GAHrC,CAAN;AAKA;AACD;AA5BiB,IAAnB;;AA8BA,OAAK,MAAM,CAACF,IAAD,EAAOmB,GAAP,CAAX,IAA0BxB,MAAM,CAACyB,OAAP,CAAejB,OAAf,CAA1B,EAAmD;AAClD;AACA,QAAIH,IAAI,KAAKE,KAAT,IAAkBF,IAAI,KAAK,MAA3B,IAAqCA,IAAI,KAAKmB,GAAG,CAACnB,IAAtD,EAA4D;AAC5D,UAAMqB,IAAI,GAAGF,GAAG,CAACX,GAAJ,CAAQc,OAAR,CAAgB,MAAhB,EAAwB,EAAxB,CAAb,CAHkD,CAIlD;;AACAZ,IAAAA,aAAa,CAAE,GAAES,GAAG,CAACI,IAAJ,GAAW,CAAX,GAAe,CAAE,IAAGvB,IAAK,EAA7B,CAAb,GAA+C,CAAC;AAACP,MAAAA;AAAD,KAAD,KAC9CA,EAAE,CAACyB,IAAH,CACE,GACAC,GAAG,CAACP,IAAJ,GACI,eAAcL,WAAY,eAAcY,GAAG,CAACR,MAAO,IAAGQ,GAAG,CAACP,IAAK,GADnE,GAEG,EACH,GACAO,GAAG,CAACK,KAAJ,GACI,UACDL,GAAG,CAACM,MAAJ,GAAa,SAAb,GAAyB,EACxB,uBAAsBjB,QAAIC,OAAJ,CACtB,GAAER,SAAU,IAAGD,IAAK,EADE,CAErB,OAAMO,WAAY,IAAGc,IAAK,KAC5BF,GAAG,CAACO,UAAJ,GAAkB,SAAQL,IAAK,cAA/B,GAA+C,EAC9C,GAPJ,GAQG,EACH,EAfF,CADD;AAkBA,GAvDI,CAwDL;;;AACA,QAAMM,iBAAiB,GAAG,EAA1B;;AACA,QAAMC,aAAa,GAAGC,SAAS,IAAI;AAClC,UAAMC,IAAI,GAAGC,EAAE,IACdA,EAAE,KACDC,WAAW,IAAI;AACf,UAAI,CAACA,WAAW,CAACC,KAAZ,CAAkBC,eAAvB,EAAwC;AACvC,cAAM;AAACD,UAAAA;AAAD,YAAUD,WAAhB;AACAA,QAAAA,WAAW,CAACC,KAAZ,GAAoB;AAACC,UAAAA,eAAe,EAAE,IAAlB,CACpB;;AADoB,SAApB;AAEAvC,QAAAA,MAAM,CAACwC,MAAP,CAAcF,KAAd,EAAqBG,OAArB,CAA6B5C,CAAC,IAAI;AACjC,cAAI,OAAOA,CAAP,KAAa,QAAjB,EAA2B;AAC3BwC,UAAAA,WAAW,CAACC,KAAZ,CAAkBzC,CAAC,CAACQ,IAApB,IAA4BT,gBAAgB,CAACC,CAAD,EAAIwC,WAAJ,CAA5C;AACA,SAHD;AAIA;;AACD,YAAMtC,KAAK,GAAGsC,WAAW,CAACC,KAAZ,CAAkBhC,SAAlB,CAAd;AACA,aAAO8B,EAAE,mBAAKzB,gBAAL;AAAuBb,QAAAA,EAAE,EAAEuC,WAA3B;AAAwCtC,QAAAA;AAAxC,SAAT;AACA,KAbC,CADH;;AAeA,WAAOoC,IAAI,CAACD,SAAS,CAACQ,EAAV,IAAgBR,SAAjB,CAAX;AACA,GAjBD;;AAkBAlC,EAAAA,MAAM,CAAC2C,IAAP,CAAY5B,aAAZ,EAA2B0B,OAA3B,CAAmCG,CAAC,IAAI;AACvC,UAAM/C,CAAC,GAAGkB,aAAa,CAAC6B,CAAD,CAAvB;AACA,QAAI/C,CAAJ,EAAOmC,iBAAiB,CAACY,CAAD,CAAjB,GAAuBX,aAAa,CAACpC,CAAD,CAApC;AACP,GAHD;AAIA,SAAOmC,iBAAP;AACA,CAxFM","sourcesContent":["import {sql} from '../DB'\n\nexport const cloneModelWithDb = (m, db) => {\n\tconst model = Object.create(m)\n\tmodel.db = db\n\tmodel._set = model._makeSetFn()\n\treturn model\n}\n\nexport const makeMigrations = ({\n\tname: tableName,\n\tidCol,\n\tcolumns,\n\tkeepRowId,\n\tmigrations,\n\tmigrationOptions,\n}) => {\n\tconst tableQuoted = sql.quoteId(tableName)\n\tconst allMigrations = {\n\t\t...migrations,\n\t\t// We make id a real column to allow foreign keys\n\t\t0: async ({db}) => {\n\t\t\tconst {quoted, type, autoIncrement} = columns[idCol]\n\t\t\tconst isIntegerId = type === 'INTEGER'\n\t\t\tconst addRowId = !isIntegerId && keepRowId\n\t\t\t// The NOT NULL is a SQLite bug, otherwise it allows NULL as id\n\t\t\tconst rowIdCol = addRowId\n\t\t\t\t? `\"rowId\" INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, `\n\t\t\t\t: ''\n\t\t\tconst keySql = addRowId\n\t\t\t\t? `${type} NOT NULL`\n\t\t\t\t: `${type} PRIMARY KEY ${\n\t\t\t\t\t\tisIntegerId && autoIncrement ? 'AUTOINCREMENT' : ''\n\t\t\t\t  } NOT NULL`\n\n\t\t\tawait db.exec(\n\t\t\t\t`CREATE TABLE ${tableQuoted}(${rowIdCol}${quoted} ${keySql}, json JSON);`\n\t\t\t)\n\t\t\tif (addRowId) {\n\t\t\t\t// implement the unique constraint with our own index\n\t\t\t\tawait db.exec(\n\t\t\t\t\t`CREATE UNIQUE INDEX ${sql.quoteId(\n\t\t\t\t\t\t`${tableName}_${idCol}`\n\t\t\t\t\t)} ON ${tableQuoted}(${sql.quoteId(idCol)})`\n\t\t\t\t)\n\t\t\t}\n\t\t},\n\t}\n\tfor (const [name, col] of Object.entries(columns)) {\n\t\t// We already added these, or it's an alias\n\t\tif (name === idCol || name === 'json' || name !== col.name) continue\n\t\tconst expr = col.sql.replace('tbl.', '')\n\t\t// Make sure real columns are created before indexes on expressions\n\t\tallMigrations[`${col.real ? 0 : 1}_${name}`] = ({db}) =>\n\t\t\tdb.exec(\n\t\t\t\t`${\n\t\t\t\t\tcol.type\n\t\t\t\t\t\t? `ALTER TABLE ${tableQuoted} ADD COLUMN ${col.quoted} ${col.type};`\n\t\t\t\t\t\t: ''\n\t\t\t\t}${\n\t\t\t\t\tcol.index\n\t\t\t\t\t\t? `CREATE ${\n\t\t\t\t\t\t\t\tcol.unique ? 'UNIQUE ' : ''\n\t\t\t\t\t\t  }INDEX IF NOT EXISTS ${sql.quoteId(\n\t\t\t\t\t\t\t\t`${tableName}_${name}`\n\t\t\t\t\t\t  )} ON ${tableQuoted}(${expr}) ${\n\t\t\t\t\t\t\t\tcol.ignoreNull ? `WHERE ${expr} IS NOT NULL` : ''\n\t\t\t\t\t\t  };`\n\t\t\t\t\t\t: ''\n\t\t\t\t}`\n\t\t\t)\n\t}\n\t// Wrap the migration functions to provide their arguments\n\tconst wrappedMigrations = {}\n\tconst wrapMigration = migration => {\n\t\tconst wrap = fn =>\n\t\t\tfn &&\n\t\t\t(writeableDb => {\n\t\t\t\tif (!writeableDb.store.__madeWriteable) {\n\t\t\t\t\tconst {store} = writeableDb\n\t\t\t\t\twriteableDb.store = {__madeWriteable: true}\n\t\t\t\t\t// Create a patched version of all models that uses the migration db\n\t\t\t\t\tObject.values(store).forEach(m => {\n\t\t\t\t\t\tif (typeof m !== 'object') return\n\t\t\t\t\t\twriteableDb.store[m.name] = cloneModelWithDb(m, writeableDb)\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t\tconst model = writeableDb.store[tableName]\n\t\t\t\treturn fn({...migrationOptions, db: writeableDb, model})\n\t\t\t})\n\t\treturn wrap(migration.up || migration)\n\t}\n\tObject.keys(allMigrations).forEach(k => {\n\t\tconst m = allMigrations[k]\n\t\tif (m) wrappedMigrations[k] = wrapMigration(m)\n\t})\n\treturn wrappedMigrations\n}\n"],"file":"makeMigrations.js"}
{"version":3,"sources":["../../src/DB/DB.js"],"names":["dbg","_getRanMigrations","db","get","exec","didRun","each","runKey","_markMigration","up","ts","Math","round","Date","now","run","DB","SQLite","constructor","migrations","onBeforeMigrations","options","onDidOpen","readOnly","runMigrations","models","process","env","NODE_ENV","warnedModel","console","error","Error","store","addModel","Model","model","name","TypeError","registerMigrations","migrationsRan","key","Object","keys","obj","push","withTransaction","values","setWritable","sql"],"mappings":"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","sourcesContent":["// @ts-check\n/* eslint-disable no-console */\nimport {sortBy} from 'lodash'\nimport debug from 'debug'\nimport SQLite, {sql} from './SQLite'\n\nconst dbg = debug('strato-db/DB')\n\nexport const _getRanMigrations = async db => {\n\tif (\n\t\t!(await db.get(`SELECT 1 FROM sqlite_master WHERE name=\"{sdb} migrations\"`))\n\t) {\n\t\tif (await db.get(`SELECT 1 FROM sqlite_master WHERE name=\"_migrations\"`))\n\t\t\tawait db.exec(`ALTER TABLE _migrations RENAME TO \"{sdb} migrations\"`)\n\t\telse\n\t\t\tawait db.exec(`CREATE TABLE \"{sdb} migrations\"(\n\t\t\t\trunKey TEXT,\n\t\t\t\tts DATETIME,\n\t\t\t\tup BOOLEAN\n\t\t\t);`)\n\t}\n\tconst didRun = {}\n\tawait db.each(\n\t\t`\n\t\t\tSELECT runKey, max(ts) AS ts, up FROM \"{sdb} migrations\"\n\t\t\tGROUP BY runKey\n\t\t\tHAVING up = 1\n\t\t`,\n\t\t({runKey}) => {\n\t\t\tdidRun[runKey] = true\n\t\t}\n\t)\n\treturn didRun\n}\n\nconst _markMigration = async (db, runKey, up) => {\n\tconst ts = Math.round(Date.now() / 1000)\n\tup = up ? 1 : 0\n\tawait db.run`INSERT INTO \"{sdb} migrations\" VALUES (${runKey}, ${ts}, ${up})`\n}\n\n/**\n * DB adds model management and migrations to Wrapper.\n * The migration state is kept in the table \"\"{sdb} migrations\"\".\n * @extends SQLite\n */\nclass DB extends SQLite {\n\t/**\n\t * @param {object} options options for DB and SQLite\n\t * @param {boolean} [options.readOnly] open the DB read-only\n\t * @param {Array} [options.migrations] migration definitions\n\t * @param {function} [options.onBeforeMigrations] called with the `db` before migrations run. Not called for read-only\n\t * @param {function} [options.onDidOpen] called with the `db` after migrations ran. If readOnly is set, it runs after opening DB. The DB is open after this function resolves\n\t */\n\tconstructor({migrations = [], onBeforeMigrations, ...options} = {}) {\n\t\tconst onDidOpen = options.readOnly\n\t\t\t? options.onDidOpen\n\t\t\t: async db => {\n\t\t\t\t\tif (onBeforeMigrations) await onBeforeMigrations(db)\n\t\t\t\t\tawait this.runMigrations(db)\n\t\t\t\t\tif (options.onDidOpen) await options.onDidOpen(db)\n\t\t\t  }\n\t\tsuper({...options, onDidOpen})\n\t\tthis.options.migrations = migrations\n\t}\n\n\tstatic sql = sql\n\n\tget models() {\n\t\tif (process.env.NODE_ENV !== 'production' && !this.warnedModel)\n\t\t\tconsole.error(\n\t\t\t\tnew Error('!!! db.models is deprecated, use db.store instead')\n\t\t\t)\n\t\treturn this.store\n\t}\n\n\t/**\n\t * Add a model to the DB, which will manage one or more tables in the SQLite database.\n\t * The model should use the given `db` instance at creation time.\n\t * @param {Object} Model - a class\n\t * @param {object} options - options passed during Model creation\n\t * @returns {object} - the created Model instance\n\t */\n\taddModel(Model, options) {\n\t\tconst model = new Model({\n\t\t\t...options,\n\t\t\tdb: this,\n\t\t})\n\t\tif (this.store[model.name])\n\t\t\tthrow new TypeError(`Model name ${model.name} was already added`)\n\t\tthis.store[model.name] = model\n\t\treturn model\n\t}\n\n\t/**\n\t * Register an object with migrations\n\t * @param {string} name - the name under which to register these migrations\n\t * @param {object<object<function>>} migrations - the migrations object\n\t * @returns {void}\n\t */\n\tregisterMigrations(name, migrations) {\n\t\tif (this.migrationsRan) {\n\t\t\tthrow new Error('migrations already done')\n\t\t}\n\t\tfor (const key of Object.keys(migrations)) {\n\t\t\tlet obj = migrations[key]\n\t\t\tif (typeof obj === 'function') {\n\t\t\t\tobj = {up: obj}\n\t\t\t} else if (!obj.up) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Migration ${key} for \"${name}\" must be a function or have an \"up({db, model, ...rest})\" attribute`\n\t\t\t\t)\n\t\t\t}\n\t\t\t// Separate with space, it sorts before other things\n\t\t\tconst runKey = `${key} ${name}`\n\t\t\tthis.options.migrations.push({\n\t\t\t\t...obj,\n\t\t\t\trunKey,\n\t\t\t})\n\t\t}\n\t}\n\n\t/**\n\t * Runs the migrations in a transaction and waits for completion\n\t * @param {SQLite} db - an opened SQLite instance\n\t * @returns {Promise<void>} - promise for completed migrations\n\t */\n\tasync runMigrations(db) {\n\t\tconst {store} = this\n\t\tconst migrations = sortBy(this.options.migrations, ({runKey}) => runKey)\n\t\tawait db.withTransaction(async () => {\n\t\t\tconst didRun = await _getRanMigrations(db)\n\t\t\tfor (const model of Object.values(store))\n\t\t\t\tif (model.setWritable) model.setWritable(true)\n\t\t\tfor (const {runKey, up} of migrations) {\n\t\t\t\tif (!didRun[runKey]) {\n\t\t\t\t\tdbg(this.name, 'start migration', runKey)\n\t\t\t\t\tawait up(db) // eslint-disable-line no-await-in-loop\n\t\t\t\t\tdbg(this.name, 'done migration', runKey)\n\t\t\t\t\tawait _markMigration(db, runKey, 1) // eslint-disable-line no-await-in-loop\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const model of Object.values(store))\n\t\t\t\tif (model.setWritable) model.setWritable(false)\n\t\t})\n\t\tthis.migrationsRan = true\n\n\t\t// Protect against store updates during migrations\n\t\tthis.store = store\n\t}\n}\n\nexport default DB\n"],"file":"DB.js"}